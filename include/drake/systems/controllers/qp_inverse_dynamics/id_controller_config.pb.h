// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: drake/systems/controllers/qp_inverse_dynamics/id_controller_config.proto

#ifndef PROTOBUF_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto__INCLUDED
#define PROTOBUF_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsVec3Impl();
void InitDefaultsVec3();
void InitDefaultsAccelerationConfigImpl();
void InitDefaultsAccelerationConfig();
void InitDefaultsContactConfigImpl();
void InitDefaultsContactConfig();
void InitDefaultsInverseDynamicsControllerConfigImpl();
void InitDefaultsInverseDynamicsControllerConfig();
inline void InitDefaults() {
  InitDefaultsVec3();
  InitDefaultsAccelerationConfig();
  InitDefaultsContactConfig();
  InitDefaultsInverseDynamicsControllerConfig();
}
}  // namespace protobuf_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto
namespace drake {
namespace systems {
namespace controllers {
namespace qp_inverse_dynamics {
class AccelerationConfig;
class AccelerationConfigDefaultTypeInternal;
extern AccelerationConfigDefaultTypeInternal _AccelerationConfig_default_instance_;
class ContactConfig;
class ContactConfigDefaultTypeInternal;
extern ContactConfigDefaultTypeInternal _ContactConfig_default_instance_;
class InverseDynamicsControllerConfig;
class InverseDynamicsControllerConfigDefaultTypeInternal;
extern InverseDynamicsControllerConfigDefaultTypeInternal _InverseDynamicsControllerConfig_default_instance_;
class Vec3;
class Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
}  // namespace qp_inverse_dynamics
}  // namespace controllers
}  // namespace systems
}  // namespace drake
namespace drake {
namespace systems {
namespace controllers {
namespace qp_inverse_dynamics {

// ===================================================================

class Vec3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:drake.systems.controllers.qp_inverse_dynamics.Vec3) */ {
 public:
  Vec3();
  virtual ~Vec3();

  Vec3(const Vec3& from);

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vec3(Vec3&& from) noexcept
    : Vec3() {
    *this = ::std::move(from);
  }

  inline Vec3& operator=(Vec3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
               &_Vec3_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Vec3* other);
  friend void swap(Vec3& a, Vec3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vec3* New() const PROTOBUF_FINAL { return New(NULL); }

  Vec3* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vec3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:drake.systems.controllers.qp_inverse_dynamics.Vec3)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto::InitDefaultsVec3Impl();
};
// -------------------------------------------------------------------

class AccelerationConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig) */ {
 public:
  AccelerationConfig();
  virtual ~AccelerationConfig();

  AccelerationConfig(const AccelerationConfig& from);

  inline AccelerationConfig& operator=(const AccelerationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccelerationConfig(AccelerationConfig&& from) noexcept
    : AccelerationConfig() {
    *this = ::std::move(from);
  }

  inline AccelerationConfig& operator=(AccelerationConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccelerationConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccelerationConfig* internal_default_instance() {
    return reinterpret_cast<const AccelerationConfig*>(
               &_AccelerationConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AccelerationConfig* other);
  friend void swap(AccelerationConfig& a, AccelerationConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccelerationConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  AccelerationConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccelerationConfig& from);
  void MergeFrom(const AccelerationConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccelerationConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double kp = 2;
  int kp_size() const;
  void clear_kp();
  static const int kKpFieldNumber = 2;
  double kp(int index) const;
  void set_kp(int index, double value);
  void add_kp(double value);
  const ::google::protobuf::RepeatedField< double >&
      kp() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_kp();

  // repeated double kd = 3;
  int kd_size() const;
  void clear_kd();
  static const int kKdFieldNumber = 3;
  double kd(int index) const;
  void set_kd(int index, double value);
  void add_kd(double value);
  const ::google::protobuf::RepeatedField< double >&
      kd() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_kd();

  // repeated double weight = 4;
  int weight_size() const;
  void clear_weight();
  static const int kWeightFieldNumber = 4;
  double weight(int index) const;
  void set_weight(int index, double value);
  void add_weight(double value);
  const ::google::protobuf::RepeatedField< double >&
      weight() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_weight();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > kp_;
  ::google::protobuf::RepeatedField< double > kd_;
  ::google::protobuf::RepeatedField< double > weight_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto::InitDefaultsAccelerationConfigImpl();
};
// -------------------------------------------------------------------

class ContactConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:drake.systems.controllers.qp_inverse_dynamics.ContactConfig) */ {
 public:
  ContactConfig();
  virtual ~ContactConfig();

  ContactConfig(const ContactConfig& from);

  inline ContactConfig& operator=(const ContactConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContactConfig(ContactConfig&& from) noexcept
    : ContactConfig() {
    *this = ::std::move(from);
  }

  inline ContactConfig& operator=(ContactConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContactConfig* internal_default_instance() {
    return reinterpret_cast<const ContactConfig*>(
               &_ContactConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ContactConfig* other);
  friend void swap(ContactConfig& a, ContactConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContactConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ContactConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContactConfig& from);
  void MergeFrom(const ContactConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContactConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .drake.systems.controllers.qp_inverse_dynamics.Vec3 contact_point = 5;
  int contact_point_size() const;
  void clear_contact_point();
  static const int kContactPointFieldNumber = 5;
  const ::drake::systems::controllers::qp_inverse_dynamics::Vec3& contact_point(int index) const;
  ::drake::systems::controllers::qp_inverse_dynamics::Vec3* mutable_contact_point(int index);
  ::drake::systems::controllers::qp_inverse_dynamics::Vec3* add_contact_point();
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::Vec3 >*
      mutable_contact_point();
  const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::Vec3 >&
      contact_point() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .drake.systems.controllers.qp_inverse_dynamics.Vec3 contact_normal = 6;
  bool has_contact_normal() const;
  void clear_contact_normal();
  static const int kContactNormalFieldNumber = 6;
  const ::drake::systems::controllers::qp_inverse_dynamics::Vec3& contact_normal() const;
  ::drake::systems::controllers::qp_inverse_dynamics::Vec3* release_contact_normal();
  ::drake::systems::controllers::qp_inverse_dynamics::Vec3* mutable_contact_normal();
  void set_allocated_contact_normal(::drake::systems::controllers::qp_inverse_dynamics::Vec3* contact_normal);

  // optional double weight = 2;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 2;
  double weight() const;
  void set_weight(double value);

  // optional double kd = 3;
  bool has_kd() const;
  void clear_kd();
  static const int kKdFieldNumber = 3;
  double kd() const;
  void set_kd(double value);

  // optional double mu = 4;
  bool has_mu() const;
  void clear_mu();
  static const int kMuFieldNumber = 4;
  double mu() const;
  void set_mu(double value);

  // optional int32 num_basis_per_contact_point = 7;
  bool has_num_basis_per_contact_point() const;
  void clear_num_basis_per_contact_point();
  static const int kNumBasisPerContactPointFieldNumber = 7;
  ::google::protobuf::int32 num_basis_per_contact_point() const;
  void set_num_basis_per_contact_point(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:drake.systems.controllers.qp_inverse_dynamics.ContactConfig)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_weight();
  void clear_has_weight();
  void set_has_kd();
  void clear_has_kd();
  void set_has_mu();
  void clear_has_mu();
  void set_has_contact_normal();
  void clear_has_contact_normal();
  void set_has_num_basis_per_contact_point();
  void clear_has_num_basis_per_contact_point();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::Vec3 > contact_point_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::drake::systems::controllers::qp_inverse_dynamics::Vec3* contact_normal_;
  double weight_;
  double kd_;
  double mu_;
  ::google::protobuf::int32 num_basis_per_contact_point_;
  friend struct ::protobuf_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto::InitDefaultsContactConfigImpl();
};
// -------------------------------------------------------------------

class InverseDynamicsControllerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig) */ {
 public:
  InverseDynamicsControllerConfig();
  virtual ~InverseDynamicsControllerConfig();

  InverseDynamicsControllerConfig(const InverseDynamicsControllerConfig& from);

  inline InverseDynamicsControllerConfig& operator=(const InverseDynamicsControllerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InverseDynamicsControllerConfig(InverseDynamicsControllerConfig&& from) noexcept
    : InverseDynamicsControllerConfig() {
    *this = ::std::move(from);
  }

  inline InverseDynamicsControllerConfig& operator=(InverseDynamicsControllerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InverseDynamicsControllerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InverseDynamicsControllerConfig* internal_default_instance() {
    return reinterpret_cast<const InverseDynamicsControllerConfig*>(
               &_InverseDynamicsControllerConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(InverseDynamicsControllerConfig* other);
  friend void swap(InverseDynamicsControllerConfig& a, InverseDynamicsControllerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InverseDynamicsControllerConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  InverseDynamicsControllerConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InverseDynamicsControllerConfig& from);
  void MergeFrom(const InverseDynamicsControllerConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InverseDynamicsControllerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig body_motion = 4;
  int body_motion_size() const;
  void clear_body_motion();
  static const int kBodyMotionFieldNumber = 4;
  const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& body_motion(int index) const;
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* mutable_body_motion(int index);
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* add_body_motion();
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >*
      mutable_body_motion();
  const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >&
      body_motion() const;

  // repeated .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig dof_motion = 6;
  int dof_motion_size() const;
  void clear_dof_motion();
  static const int kDofMotionFieldNumber = 6;
  const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& dof_motion(int index) const;
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* mutable_dof_motion(int index);
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* add_dof_motion();
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >*
      mutable_dof_motion();
  const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >&
      dof_motion() const;

  // repeated .drake.systems.controllers.qp_inverse_dynamics.ContactConfig contact = 8;
  int contact_size() const;
  void clear_contact();
  static const int kContactFieldNumber = 8;
  const ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig& contact(int index) const;
  ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* mutable_contact(int index);
  ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* add_contact();
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig >*
      mutable_contact();
  const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig >&
      contact() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig centroidal_momentum = 2;
  bool has_centroidal_momentum() const;
  void clear_centroidal_momentum();
  static const int kCentroidalMomentumFieldNumber = 2;
  const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& centroidal_momentum() const;
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* release_centroidal_momentum();
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* mutable_centroidal_momentum();
  void set_allocated_centroidal_momentum(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* centroidal_momentum);

  // optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig default_body_motion = 3;
  bool has_default_body_motion() const;
  void clear_default_body_motion();
  static const int kDefaultBodyMotionFieldNumber = 3;
  const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& default_body_motion() const;
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* release_default_body_motion();
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* mutable_default_body_motion();
  void set_allocated_default_body_motion(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_body_motion);

  // optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig default_dof_motion = 5;
  bool has_default_dof_motion() const;
  void clear_default_dof_motion();
  static const int kDefaultDofMotionFieldNumber = 5;
  const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& default_dof_motion() const;
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* release_default_dof_motion();
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* mutable_default_dof_motion();
  void set_allocated_default_dof_motion(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_dof_motion);

  // optional .drake.systems.controllers.qp_inverse_dynamics.ContactConfig default_contact = 7;
  bool has_default_contact() const;
  void clear_default_contact();
  static const int kDefaultContactFieldNumber = 7;
  const ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig& default_contact() const;
  ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* release_default_contact();
  ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* mutable_default_contact();
  void set_allocated_default_contact(::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* default_contact);

  // optional double contact_force_basis_weight = 9;
  bool has_contact_force_basis_weight() const;
  void clear_contact_force_basis_weight();
  static const int kContactForceBasisWeightFieldNumber = 9;
  double contact_force_basis_weight() const;
  void set_contact_force_basis_weight(double value);

  // @@protoc_insertion_point(class_scope:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_centroidal_momentum();
  void clear_has_centroidal_momentum();
  void set_has_default_body_motion();
  void clear_has_default_body_motion();
  void set_has_default_dof_motion();
  void clear_has_default_dof_motion();
  void set_has_default_contact();
  void clear_has_default_contact();
  void set_has_contact_force_basis_weight();
  void clear_has_contact_force_basis_weight();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig > body_motion_;
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig > dof_motion_;
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig > contact_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* centroidal_momentum_;
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_body_motion_;
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_dof_motion_;
  ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* default_contact_;
  double contact_force_basis_weight_;
  friend struct ::protobuf_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto::InitDefaultsInverseDynamicsControllerConfigImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec3

// optional double x = 1;
inline bool Vec3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vec3::x() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.Vec3.x)
  return x_;
}
inline void Vec3::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.Vec3.x)
}

// optional double y = 2;
inline bool Vec3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vec3::y() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.Vec3.y)
  return y_;
}
inline void Vec3::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.Vec3.y)
}

// optional double z = 3;
inline bool Vec3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vec3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vec3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vec3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vec3::z() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.Vec3.z)
  return z_;
}
inline void Vec3::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.Vec3.z)
}

// -------------------------------------------------------------------

// AccelerationConfig

// optional string name = 1;
inline bool AccelerationConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccelerationConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccelerationConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccelerationConfig::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& AccelerationConfig::name() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
  return name_.GetNoArena();
}
inline void AccelerationConfig::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
}
#if LANG_CXX11
inline void AccelerationConfig::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
}
#endif
inline void AccelerationConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
}
inline void AccelerationConfig::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
}
inline ::std::string* AccelerationConfig::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccelerationConfig::release_name() {
  // @@protoc_insertion_point(field_release:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccelerationConfig::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
}

// repeated double kp = 2;
inline int AccelerationConfig::kp_size() const {
  return kp_.size();
}
inline void AccelerationConfig::clear_kp() {
  kp_.Clear();
}
inline double AccelerationConfig::kp(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kp)
  return kp_.Get(index);
}
inline void AccelerationConfig::set_kp(int index, double value) {
  kp_.Set(index, value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kp)
}
inline void AccelerationConfig::add_kp(double value) {
  kp_.Add(value);
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kp)
}
inline const ::google::protobuf::RepeatedField< double >&
AccelerationConfig::kp() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kp)
  return kp_;
}
inline ::google::protobuf::RepeatedField< double >*
AccelerationConfig::mutable_kp() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kp)
  return &kp_;
}

// repeated double kd = 3;
inline int AccelerationConfig::kd_size() const {
  return kd_.size();
}
inline void AccelerationConfig::clear_kd() {
  kd_.Clear();
}
inline double AccelerationConfig::kd(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kd)
  return kd_.Get(index);
}
inline void AccelerationConfig::set_kd(int index, double value) {
  kd_.Set(index, value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kd)
}
inline void AccelerationConfig::add_kd(double value) {
  kd_.Add(value);
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kd)
}
inline const ::google::protobuf::RepeatedField< double >&
AccelerationConfig::kd() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kd)
  return kd_;
}
inline ::google::protobuf::RepeatedField< double >*
AccelerationConfig::mutable_kd() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kd)
  return &kd_;
}

// repeated double weight = 4;
inline int AccelerationConfig::weight_size() const {
  return weight_.size();
}
inline void AccelerationConfig::clear_weight() {
  weight_.Clear();
}
inline double AccelerationConfig::weight(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.weight)
  return weight_.Get(index);
}
inline void AccelerationConfig::set_weight(int index, double value) {
  weight_.Set(index, value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.weight)
}
inline void AccelerationConfig::add_weight(double value) {
  weight_.Add(value);
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.weight)
}
inline const ::google::protobuf::RepeatedField< double >&
AccelerationConfig::weight() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.weight)
  return weight_;
}
inline ::google::protobuf::RepeatedField< double >*
AccelerationConfig::mutable_weight() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.weight)
  return &weight_;
}

// -------------------------------------------------------------------

// ContactConfig

// optional string name = 1;
inline bool ContactConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactConfig::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ContactConfig::name() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
  return name_.GetNoArena();
}
inline void ContactConfig::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
}
#if LANG_CXX11
inline void ContactConfig::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
}
#endif
inline void ContactConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
}
inline void ContactConfig::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
}
inline ::std::string* ContactConfig::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContactConfig::release_name() {
  // @@protoc_insertion_point(field_release:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContactConfig::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
}

// optional double weight = 2;
inline bool ContactConfig::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactConfig::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactConfig::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactConfig::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double ContactConfig::weight() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.weight)
  return weight_;
}
inline void ContactConfig::set_weight(double value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.weight)
}

// optional double kd = 3;
inline bool ContactConfig::has_kd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContactConfig::set_has_kd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContactConfig::clear_has_kd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContactConfig::clear_kd() {
  kd_ = 0;
  clear_has_kd();
}
inline double ContactConfig::kd() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.kd)
  return kd_;
}
inline void ContactConfig::set_kd(double value) {
  set_has_kd();
  kd_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.kd)
}

// optional double mu = 4;
inline bool ContactConfig::has_mu() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContactConfig::set_has_mu() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContactConfig::clear_has_mu() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContactConfig::clear_mu() {
  mu_ = 0;
  clear_has_mu();
}
inline double ContactConfig::mu() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.mu)
  return mu_;
}
inline void ContactConfig::set_mu(double value) {
  set_has_mu();
  mu_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.mu)
}

// repeated .drake.systems.controllers.qp_inverse_dynamics.Vec3 contact_point = 5;
inline int ContactConfig::contact_point_size() const {
  return contact_point_.size();
}
inline void ContactConfig::clear_contact_point() {
  contact_point_.Clear();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::Vec3& ContactConfig::contact_point(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_point)
  return contact_point_.Get(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* ContactConfig::mutable_contact_point(int index) {
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_point)
  return contact_point_.Mutable(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* ContactConfig::add_contact_point() {
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_point)
  return contact_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::Vec3 >*
ContactConfig::mutable_contact_point() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_point)
  return &contact_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::Vec3 >&
ContactConfig::contact_point() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_point)
  return contact_point_;
}

// optional .drake.systems.controllers.qp_inverse_dynamics.Vec3 contact_normal = 6;
inline bool ContactConfig::has_contact_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactConfig::set_has_contact_normal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactConfig::clear_has_contact_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactConfig::clear_contact_normal() {
  if (contact_normal_ != NULL) contact_normal_->Clear();
  clear_has_contact_normal();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::Vec3& ContactConfig::contact_normal() const {
  const ::drake::systems::controllers::qp_inverse_dynamics::Vec3* p = contact_normal_;
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_normal)
  return p != NULL ? *p : *reinterpret_cast<const ::drake::systems::controllers::qp_inverse_dynamics::Vec3*>(
      &::drake::systems::controllers::qp_inverse_dynamics::_Vec3_default_instance_);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* ContactConfig::release_contact_normal() {
  // @@protoc_insertion_point(field_release:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_normal)
  clear_has_contact_normal();
  ::drake::systems::controllers::qp_inverse_dynamics::Vec3* temp = contact_normal_;
  contact_normal_ = NULL;
  return temp;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* ContactConfig::mutable_contact_normal() {
  set_has_contact_normal();
  if (contact_normal_ == NULL) {
    contact_normal_ = new ::drake::systems::controllers::qp_inverse_dynamics::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_normal)
  return contact_normal_;
}
inline void ContactConfig::set_allocated_contact_normal(::drake::systems::controllers::qp_inverse_dynamics::Vec3* contact_normal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete contact_normal_;
  }
  if (contact_normal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contact_normal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contact_normal, submessage_arena);
    }
    set_has_contact_normal();
  } else {
    clear_has_contact_normal();
  }
  contact_normal_ = contact_normal;
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_normal)
}

// optional int32 num_basis_per_contact_point = 7;
inline bool ContactConfig::has_num_basis_per_contact_point() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContactConfig::set_has_num_basis_per_contact_point() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContactConfig::clear_has_num_basis_per_contact_point() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContactConfig::clear_num_basis_per_contact_point() {
  num_basis_per_contact_point_ = 0;
  clear_has_num_basis_per_contact_point();
}
inline ::google::protobuf::int32 ContactConfig::num_basis_per_contact_point() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.num_basis_per_contact_point)
  return num_basis_per_contact_point_;
}
inline void ContactConfig::set_num_basis_per_contact_point(::google::protobuf::int32 value) {
  set_has_num_basis_per_contact_point();
  num_basis_per_contact_point_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.num_basis_per_contact_point)
}

// -------------------------------------------------------------------

// InverseDynamicsControllerConfig

// optional string name = 1;
inline bool InverseDynamicsControllerConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InverseDynamicsControllerConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InverseDynamicsControllerConfig::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& InverseDynamicsControllerConfig::name() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
  return name_.GetNoArena();
}
inline void InverseDynamicsControllerConfig::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
}
#if LANG_CXX11
inline void InverseDynamicsControllerConfig::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
}
#endif
inline void InverseDynamicsControllerConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
}
inline void InverseDynamicsControllerConfig::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
}
inline ::std::string* InverseDynamicsControllerConfig::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InverseDynamicsControllerConfig::release_name() {
  // @@protoc_insertion_point(field_release:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InverseDynamicsControllerConfig::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
}

// optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig centroidal_momentum = 2;
inline bool InverseDynamicsControllerConfig::has_centroidal_momentum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_centroidal_momentum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InverseDynamicsControllerConfig::clear_has_centroidal_momentum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InverseDynamicsControllerConfig::clear_centroidal_momentum() {
  if (centroidal_momentum_ != NULL) centroidal_momentum_->Clear();
  clear_has_centroidal_momentum();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& InverseDynamicsControllerConfig::centroidal_momentum() const {
  const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* p = centroidal_momentum_;
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.centroidal_momentum)
  return p != NULL ? *p : *reinterpret_cast<const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig*>(
      &::drake::systems::controllers::qp_inverse_dynamics::_AccelerationConfig_default_instance_);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::release_centroidal_momentum() {
  // @@protoc_insertion_point(field_release:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.centroidal_momentum)
  clear_has_centroidal_momentum();
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* temp = centroidal_momentum_;
  centroidal_momentum_ = NULL;
  return temp;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::mutable_centroidal_momentum() {
  set_has_centroidal_momentum();
  if (centroidal_momentum_ == NULL) {
    centroidal_momentum_ = new ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig;
  }
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.centroidal_momentum)
  return centroidal_momentum_;
}
inline void InverseDynamicsControllerConfig::set_allocated_centroidal_momentum(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* centroidal_momentum) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete centroidal_momentum_;
  }
  if (centroidal_momentum) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      centroidal_momentum = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, centroidal_momentum, submessage_arena);
    }
    set_has_centroidal_momentum();
  } else {
    clear_has_centroidal_momentum();
  }
  centroidal_momentum_ = centroidal_momentum;
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.centroidal_momentum)
}

// optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig default_body_motion = 3;
inline bool InverseDynamicsControllerConfig::has_default_body_motion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_default_body_motion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InverseDynamicsControllerConfig::clear_has_default_body_motion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InverseDynamicsControllerConfig::clear_default_body_motion() {
  if (default_body_motion_ != NULL) default_body_motion_->Clear();
  clear_has_default_body_motion();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& InverseDynamicsControllerConfig::default_body_motion() const {
  const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* p = default_body_motion_;
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_body_motion)
  return p != NULL ? *p : *reinterpret_cast<const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig*>(
      &::drake::systems::controllers::qp_inverse_dynamics::_AccelerationConfig_default_instance_);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::release_default_body_motion() {
  // @@protoc_insertion_point(field_release:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_body_motion)
  clear_has_default_body_motion();
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* temp = default_body_motion_;
  default_body_motion_ = NULL;
  return temp;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::mutable_default_body_motion() {
  set_has_default_body_motion();
  if (default_body_motion_ == NULL) {
    default_body_motion_ = new ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig;
  }
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_body_motion)
  return default_body_motion_;
}
inline void InverseDynamicsControllerConfig::set_allocated_default_body_motion(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_body_motion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete default_body_motion_;
  }
  if (default_body_motion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      default_body_motion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, default_body_motion, submessage_arena);
    }
    set_has_default_body_motion();
  } else {
    clear_has_default_body_motion();
  }
  default_body_motion_ = default_body_motion;
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_body_motion)
}

// repeated .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig body_motion = 4;
inline int InverseDynamicsControllerConfig::body_motion_size() const {
  return body_motion_.size();
}
inline void InverseDynamicsControllerConfig::clear_body_motion() {
  body_motion_.Clear();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& InverseDynamicsControllerConfig::body_motion(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.body_motion)
  return body_motion_.Get(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::mutable_body_motion(int index) {
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.body_motion)
  return body_motion_.Mutable(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::add_body_motion() {
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.body_motion)
  return body_motion_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >*
InverseDynamicsControllerConfig::mutable_body_motion() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.body_motion)
  return &body_motion_;
}
inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >&
InverseDynamicsControllerConfig::body_motion() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.body_motion)
  return body_motion_;
}

// optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig default_dof_motion = 5;
inline bool InverseDynamicsControllerConfig::has_default_dof_motion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_default_dof_motion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InverseDynamicsControllerConfig::clear_has_default_dof_motion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InverseDynamicsControllerConfig::clear_default_dof_motion() {
  if (default_dof_motion_ != NULL) default_dof_motion_->Clear();
  clear_has_default_dof_motion();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& InverseDynamicsControllerConfig::default_dof_motion() const {
  const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* p = default_dof_motion_;
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_dof_motion)
  return p != NULL ? *p : *reinterpret_cast<const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig*>(
      &::drake::systems::controllers::qp_inverse_dynamics::_AccelerationConfig_default_instance_);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::release_default_dof_motion() {
  // @@protoc_insertion_point(field_release:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_dof_motion)
  clear_has_default_dof_motion();
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* temp = default_dof_motion_;
  default_dof_motion_ = NULL;
  return temp;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::mutable_default_dof_motion() {
  set_has_default_dof_motion();
  if (default_dof_motion_ == NULL) {
    default_dof_motion_ = new ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig;
  }
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_dof_motion)
  return default_dof_motion_;
}
inline void InverseDynamicsControllerConfig::set_allocated_default_dof_motion(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_dof_motion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete default_dof_motion_;
  }
  if (default_dof_motion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      default_dof_motion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, default_dof_motion, submessage_arena);
    }
    set_has_default_dof_motion();
  } else {
    clear_has_default_dof_motion();
  }
  default_dof_motion_ = default_dof_motion;
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_dof_motion)
}

// repeated .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig dof_motion = 6;
inline int InverseDynamicsControllerConfig::dof_motion_size() const {
  return dof_motion_.size();
}
inline void InverseDynamicsControllerConfig::clear_dof_motion() {
  dof_motion_.Clear();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& InverseDynamicsControllerConfig::dof_motion(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.dof_motion)
  return dof_motion_.Get(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::mutable_dof_motion(int index) {
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.dof_motion)
  return dof_motion_.Mutable(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::add_dof_motion() {
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.dof_motion)
  return dof_motion_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >*
InverseDynamicsControllerConfig::mutable_dof_motion() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.dof_motion)
  return &dof_motion_;
}
inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >&
InverseDynamicsControllerConfig::dof_motion() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.dof_motion)
  return dof_motion_;
}

// optional .drake.systems.controllers.qp_inverse_dynamics.ContactConfig default_contact = 7;
inline bool InverseDynamicsControllerConfig::has_default_contact() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_default_contact() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InverseDynamicsControllerConfig::clear_has_default_contact() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InverseDynamicsControllerConfig::clear_default_contact() {
  if (default_contact_ != NULL) default_contact_->Clear();
  clear_has_default_contact();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig& InverseDynamicsControllerConfig::default_contact() const {
  const ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* p = default_contact_;
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_contact)
  return p != NULL ? *p : *reinterpret_cast<const ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig*>(
      &::drake::systems::controllers::qp_inverse_dynamics::_ContactConfig_default_instance_);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* InverseDynamicsControllerConfig::release_default_contact() {
  // @@protoc_insertion_point(field_release:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_contact)
  clear_has_default_contact();
  ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* temp = default_contact_;
  default_contact_ = NULL;
  return temp;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* InverseDynamicsControllerConfig::mutable_default_contact() {
  set_has_default_contact();
  if (default_contact_ == NULL) {
    default_contact_ = new ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig;
  }
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_contact)
  return default_contact_;
}
inline void InverseDynamicsControllerConfig::set_allocated_default_contact(::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* default_contact) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete default_contact_;
  }
  if (default_contact) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      default_contact = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, default_contact, submessage_arena);
    }
    set_has_default_contact();
  } else {
    clear_has_default_contact();
  }
  default_contact_ = default_contact;
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_contact)
}

// repeated .drake.systems.controllers.qp_inverse_dynamics.ContactConfig contact = 8;
inline int InverseDynamicsControllerConfig::contact_size() const {
  return contact_.size();
}
inline void InverseDynamicsControllerConfig::clear_contact() {
  contact_.Clear();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig& InverseDynamicsControllerConfig::contact(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact)
  return contact_.Get(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* InverseDynamicsControllerConfig::mutable_contact(int index) {
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact)
  return contact_.Mutable(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* InverseDynamicsControllerConfig::add_contact() {
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact)
  return contact_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig >*
InverseDynamicsControllerConfig::mutable_contact() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact)
  return &contact_;
}
inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig >&
InverseDynamicsControllerConfig::contact() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact)
  return contact_;
}

// optional double contact_force_basis_weight = 9;
inline bool InverseDynamicsControllerConfig::has_contact_force_basis_weight() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_contact_force_basis_weight() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InverseDynamicsControllerConfig::clear_has_contact_force_basis_weight() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InverseDynamicsControllerConfig::clear_contact_force_basis_weight() {
  contact_force_basis_weight_ = 0;
  clear_has_contact_force_basis_weight();
}
inline double InverseDynamicsControllerConfig::contact_force_basis_weight() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact_force_basis_weight)
  return contact_force_basis_weight_;
}
inline void InverseDynamicsControllerConfig::set_contact_force_basis_weight(double value) {
  set_has_contact_force_basis_weight();
  contact_force_basis_weight_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact_force_basis_weight)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace qp_inverse_dynamics
}  // namespace controllers
}  // namespace systems
}  // namespace drake

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_drake_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto__INCLUDED
